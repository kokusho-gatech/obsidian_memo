---
tags:
  - 書類重複確認削減Pj
creation-date: "20250730"
---

# Pjの目的

Acqusition事業部ないの各部署での同一書類に関する重複確認をなくすこと

対象部署：Contract, Settlement, Document/Main Document/Maisoku, Succession

## ドラフトチェックページで対応する場合の機能ごとの対応要否の整理

◎：対応不要、◯：現状対応不要、△：対応必要、✖️：対応必須
必要な機能：
- 書類転記画面
	- 書類の種別選択：◯
	  6種類のみの場合対応不要。書類種別を追加する際には種別ごとのテーブルの追加やビューの調整が必要。
	  
	- 書類のバージョン選択：△
	  書類のバージョン管理を行わないスコープにした場合は対応不要。
	  
	- 書面のグラフィカル表示：対応不要
	  
	- 書類の転記入力欄と保存処理：◯
	  現状の項目のみの場合対応不要。項目追加する際にはデータカラムの追加とビューの調整が必要。
	  
	- 前回確定情報の表示機能：△
	  書類のバージョン管理を行わないスコープにした場合は対応不要。
	  
	- 確定申請/承認機能：✖️
	  現状、ステータスの単一選択のみであるため、対応必須
	  　・一定権限以上のユーザのみ確定が可能
	  　・承認、確定フェーズではデータロックをかける
	  
	- 書類紐付け：△
	  書類ファイルに対してではなく案件に対して情報を持つという方針の場合、対応不要
	  
	- 過去書類の情報をコピー：△
	  書類のバージョン管理を行わないスコープにした場合は対応不要。
	  
	- OCR読み取り結果の入力補助：◯
	  現状の項目のみの場合対応不要。項目を増やしていく場合、対応必要
	  
 - ドラフトチェックページの改修
	 - 書類情報の引用表示：◎
	 - 書類情報画面への遷移：◎
	   
 - その他画面からの遷移
	 - ファイルチェックページからの遷移：◎
	 - 一致比較info表示からの遷移：◎
	   
- その他の機能
	- 各方針で差異がないため省略

## ドラフトチェックページで対応する場合の開発工数の削減度合い

想定される対応工数：大、中、小
Case1: バージョン周りの機能をつけない & 自己参照（書類通しのリレーション）を実現しない
　　対応不要項目：
　　　- 書類の種別選択：小
　　　- 書類のバージョン選択：大
　　　- 書面のグラフィカル表示：小
　　　- 書類の転記入力欄と保存処理：中
　　　- 前回確定情報の表示機能：中
　　　- 書類紐付け：大
　　　- 過去書類の情報をコピー：小
　　　- OCR読み取り結果の入力補助：中
　　　- ドラフトチェックページの改修
	　　　- 書類情報の引用表示：中
	　　　- 書類情報画面への遷移：小
	   - その他画面からの遷移
		   - ファイルチェックページからの遷移：小
		   - 一致比較info表示からの遷移：小

Case2: バージョン管理や書類紐付けなど、当初の要件をドラフトチェックページでも実現する場合
　　対応不要項目：
　　　- 書類の種別選択
　　　- 書面のグラフィカル表示
　　　- 書類の転記入力欄と保存処理
　　　- OCR読み取り結果の入力補助
　　　- ドラフトチェックページの改修
	　　　- 書類情報の引用表示
	　　　- 書類情報画面への遷移
	   - その他画面からの遷移
		   - ファイルチェックページからの遷移
		   - 一致比較info表示からの遷移

　
## ドラフトチェックページで対応する場合のインパクト縮小の度合い

制約：コントラクトチームが確認している項目のみに限定される

現状のドラフトチェックページに記載の情報のみの場合
　マイソク作成チーム　20項目 ⇨ 6項目
　契約書作成チーム　 80項目 ⇨ 16項目
　決済（FLOWユーザ）　15項目 ⇨ 10項目
　承継（MNGユーザ）　25項目 ⇨ 14項目
　
　そのため、140項目⇨46項目というインパクト縮小が考えられる。
　46項目の場合、年間の想定インパクト（削減人件費）は460万円となった。
　（1項目の削減⇨11.5万円）




```dataviewjs
dv.header(3, "関連ノート");
var maxLoop = Math.min(dv.current().file.tags.length, 3);
for(let i=0;i<maxLoop;i++){
dv.span(dv.current().file.tags[i]);
dv.list(dv.pages(dv.current().file.tags[i]).sort(f=>f.file.mtime.ts,"desc").limit(15).file.link);
}

for (let outgo of dv.pages('outgoing([[' + dv.current().file.name + ']])')) {
    dv.header(4, outgo.file.name);
    dv.list(outgo.file.inlinks.sort());
}

// バックリンクがあるノートも出力
let backlinks = dv.pages().where(p => p.file.inlinks && p.file.inlinks.map(l=>l.path).includes(dv.current().file.path));
if (backlinks.length > 0) {
    dv.header(3, "このノートへのバックリンク");
    dv.list(backlinks.file.link);
}

```